# Teoría - Parcial I

### 1. El sistema Operativo…

- [ ]  Se ejecuta en modo Usuario, sin acceso al hardware de la computadora
    
    <aside>
    ❌
    
    El **SO no se ejecuta en modo usuario, ya que se ejecutan en modo Kernel para proteger la integridad del sistema** y gestionar el Hardware. Las aplicaciones de usuario si lo hacen
    
    </aside>
    
- [ ]  Se ejecuta en modo Kernel, con Acceso restringido al hardware de la computadora
    
    <aside>
    ❌
    
    El modo Kernel, por definicion, otorga acceso total y sin restricciones al hardware. Taneubaum afirma que el modo Kernel tiene “Privilegios Completos”
    
    </aside>
    
- [x]  Se ejecuta en modo Kernel, con total acceso al hardware de la computadora
    
    <aside>
    ✅
    
    El modo Kernel, por definicion, otorga acceso total y sin restricciones al hardware. Es crucial que utilice este modo para planificacion de procesos, gestion de memoria, y protección del sistema, sin restricciones.
    
    </aside>
    
- [ ]  Ninguna de las anteriores es correcta.

### 2. La diferencia entre un programa y un proceso es…

- [ ]  Un proceso es estático, y no esta siendo ejecutado por la CPU, y un programa es solo datos
    
    <aside>
    ❌
    
    El proceso no es estático, y un programa es un conjunto de datos e instrucciones almacenados de forma pasiva. Es el programa la parte estática.
    
    </aside>
    
- [x]  Un proceso es dinámico.
    
    <aside>
    ✅
    
    Un proceso es una entidad dinámica, activa, representa la EJECUCIÓN del programa. Tiene variables, contador de Programa, registros, y otros recursos.
    
    </aside>
    
- [ ]  Ninguna es correcta.
- [ ]  Las dos son correctas

### 3. Un proceso pasa de ejecución a listo cuando:

- [ ]  La entrada por la que esperaba esta disponible
    
    <aside>
    ❌
    
    Esta es la transición de Estado **bloqueado a libre.**
    
    </aside>
    
- [ ]  El planificador lo selecciona
    
    <aside>
    ❌
    
    Esta es la transición de Estado **Libre a Ejecución.**
    
    </aside>
    

- [x]  El planificador selecciona otro proceso.
    
    <aside>
    ✅
    
    El **estado pasa de Ejecución a listo** ya que el planificador decide asignar la CPU a otro proceso.
    
    </aside>
    
- [ ]  Ninguna es correcta.

### 4. Un hilo…

- [x]  Comparte código: Datos globales, archivos abiertos con otros hilos dentro de un mismo proceso
    
    <aside>
    ✅
    
    El hilo comparte sus recursos SOLAMENTE con otros hilos de un MISMO proceso pesado.
    
    </aside>
    
- [ ]  No comparte código, datos globales, archivos abiertos con otros hilos, dentro de un mismo proceso.
    
    <aside>
    ❌
    
    Falso, ya que si comparte recursos con otros hilos dentro de un mismo proceso
    
    </aside>
    
- [ ]  Comparte código, datos globales, archivos abiertos con hilos de otros procesos
    
    <aside>
    ❌
    
    No comparte recursos con hilos de otros procesos
    
    </aside>
    
- [ ]  Todas las anteriores son correctas.

### 5. En caso de utilizar hilos

- [x]  Los hilos dentro de un HWP no son independientes.
    
    <aside>
    ✅
    
    Los **hilos dentro de un proceso comparten el mismo espacio de direcciones de memoria, archivos abiertos, y otros recursos**.
    
    </aside>
    
- [ ]  El espacio de direcciones de memoria RAM no es compartido.
    
    <aside>
    ❌
    
    Los hilos de un proceso comparten exactamente el mismo espacio de direcciones de memoria
    
    </aside>
    
- [ ]  El acceso a memoria compartida no necesita control.
    
    <aside>
    ❌
    
    El acceso concurrente a memoria compartida necesita mecanismos de sincronizacion para evitar problemas de consistencia. Ej: Como un mutex.
    
    </aside>
    
- [ ]  No pueden aparecer condiciones de carrera.
    
    <aside>
    ❌
    
    Son un riesgo inherente cuando multiples hilos acceden a datos compartidos sin sincronizacion.
    
    </aside>
    

### 6. Cuando se realiza un cambio de contexto a raíz de una interrupción

- [x]  Se almacena el psw y el pc del programa en ejecución en una pila
    
    <aside>
    ✅
    
    l hardware guarda automáticamente el **PSW (Program Status Word)** y el **PC (Program Counter)** del proceso en ejecución en una pila del kernel. Esto permite conservar el estado del proceso para restaurarlo posteriormente cuando se reanude su ejecución. Tanenbaum enfatiza que este paso es crítico para la gestión de procesos, ya que garantiza que el sistema operativo pueda interrumpir y reanudar procesos de manera transparente.
    
    </aside>
    
- [ ]  El programa en ejecución pasa a la cola de listos
    
    <aside>
    ❌
    
     **no siempre es cierto**. El proceso en **ejecución puede pasar a la cola de listos si fue desalojado por el planificador** (ej. por expiración de su quantum), p**ero si la interrupción causa que el proceso se bloquee** (ej. esperando una operación de E/S), **pasará a la cola de bloqueados.**
    
    </aside>
    
- [ ]  Se deshabilita el bus.
    
    <aside>
    ❌
    
    Tanenbaum no menciona que el bus se deshabilite durante un cambio de contexto. En lugar de ello, el manejo de interrupciones implica deshabilitar **interrupciones adicionales** temporalmente en el CPU para proteger estructuras críticas del kernel, pero no se deshabilita el bus del sistema.
    
    </aside>
    
- [ ]  Todas las opciones anteriores son correctas.

### 7. Los semáforos mutex:

- [ ]  Deben inicializarse en cualquier valor entero no negativo
    
    <aside>
    ❌
    
    Esta descripción corresponde a los **semáforos de conteo generales**, no a los mutex. Los mutex son binarios y solo admiten los valores 0 y 1.
    
    </aside>
    
- [x]  Deben inicializarse en uno
    
    <aside>
    ✅
    
    Los **semáforos Mutex** son semáforos con funcionamiento binario, creados específicamente para garantizar acceso **EXCLUSIVO** a una sección critica. Deben inicializarse en 1, para indicar que el recurso esta disponible inicialmente
    
    </aside>
    
- [ ]  Deben inicializarse en cualquier valor que no sea cero
    
    <aside>
    ❌
    
    No se trata de cualquier valor, **ya que si se inicializa con un valor superior a 1**, viola su propósito binario. Debe inicializarse explícitamente en uno.
    
    </aside>
    
- [ ]  No es necesario que se inicialicen
    
    <aside>
    ❌
    
    No se trata de cualquier valor, **ya que si se inicializa con un valor superior a 1**, viola su propósito binario. Debe inicializarse explícitamente en uno.
    
    </aside>
    
- [ ]  Ninguna de las anteriores

### 8. Una subrutina puede implementarse como hilo(proceso ligero), es decir, como un hilo de ejecución independiente del hilo de ejecución del proceso que lo invoca, o bien, como un procedimiento que se ejecuta dentro del mismo hilo del proceso que lo invoca, una diferencia entre esas dos formas de implementación es:

- [ ]  El proceso ligero debe tener su propio "Registro de estado", independiente del que tiene el proceso que lo invoca, y en el otro caso no es necesario.
- [ ]  El proceso ligero debe tener su propio registro contador de programa, independiente del que tiene el proceso que lo invoca, y en e otro caso no es necesario.
- [ ]  El proceso ligero debe tener su propio "Registro puntero de pila", independiente del que tiene el proceso que lo invoca, y en el otro caso no es necesario.
- [x]  Las tres opciones anteriores son validas
    
    <aside>
    ✅
    
    Cuando un subrutina se implementa como un hilo(Proceso ligero) independiente, cada hilo debe tener su propio contexto de ejecución privado, es decir, cada uno de los siguientes registros de forma INDEPENDIENTE: 
    - Un Registro de estado**(PSW)**
    - Un Registro Contador de Programa**(PC)**: Para llevar el control de la instrucción actual que ejecuta cada hilo.
    - Un **Registro puntero de pila**
    
    </aside>
    
- [ ]  Ninguna de las anteriores

### 9. Uno de los mecanismos de exclusión mutua entre regiones criticas es la desactivación de interrupciones. Cual de las siguientes afirmaciones es correcta?

- [ ]  La exclusión es segura aunque haya multiples procesados ejecutando procesos en paralelo
    
    <aside>
    ❌
    
    Tanenbaum enfatiza que la desactivación de interrupciones NO FUNCIONA en sistemas de **múltiples CPUS**.
    
    </aside>
    
- [ ]  La exclusión se asegura por que se desactivan las interrupciones internas, por lo que no podrá ejecutarse otro proceso
    
    <aside>
    ❌
    
    No existe una división entre interrupciones internas u externas.
    
    </aside>
    
- [ ]  La exclusión se asegura por que el planificador le da prioridad alta al proceso que entra en su región critica
    
    <aside>
    ❌
    
    La desactivación de interrupciones no involucra al planificacdor ni se basa en prioridades. Es un mecanismo de bajo nivel donde el proceso mismo desactiva las interrupciones de Hardware.
    
    </aside>
    
- [ ]  Las tres anteriores son validas
- [x]  Ninguna de las anterioresC
    
    <aside>
    ✅
    
    Desactivar interrupciones **solo es efectivo en sistemas MONOPROCESADOR**, al desactivar interrupciones, el sistema busca evitar ser interrumpido por el planificador, garantizando que ningún otro proceso se ejecute por el planificador.
    
    </aside>
    

### 10. Cuando desde un proceso de usuario se ejecuta una llamada al sistema, implica que el SO:

- [ ]  Ejecute el planificador de procesos para darle prioridad a la ejecución del servicio del SO
    
    <aside>
    ❌
    
    El **SO no ejecuta el planificador para priorizar su propio servicio. La llamada al sistema se ejecuta en el contexto del proceso que la invoca** y la priorización se maneja mediante mecanismos de planificación INDEPENDIENTES.
    
    </aside>
    
- [ ]  Ejecute el planificador de procesos para establecer cual es el próximo proceso a ejecutarse.
    
    La **llamada al sistema no desencadena automáticamente el planificador.** Este se ejecuta si la llamada al sistema causa un cambio de estado en el proceso.
    
    <aside>
    ❌
    
    </aside>
    
- [ ]  Ejecute el planificador de procesos para cambiar a estado de bloqueado al resto de los procesos
    
    <aside>
    ❌
    
    Una **llamada al sistema no bloquea todos los procesos del sistema**. Solo el proceso que invoca la llamada puede bloquearse si espera un recurso pero no afecta al resto de forma general.
    
    </aside>
    
- [ ]  En este caso el SO no ejecuta el planificador de Procesos
    
    <aside>
    ❌
    
    Aunque no es una consecuencia directa, **el planificador se ejecuta si la llamada al sistema resulta en el bloqueo del proceso** o en otro evento planificable.
    
    </aside>
    
- [ ]  Ninguna de las anteriores
    
    <aside>
    ✅
    
    Cuando un  proceso de usuario ejecuta una llamada al sistema, se produce un cambio de modo de usuario a modo Kernel, donde el SO ejecuta el código correspondiente al servicio solicitado. Sin embargo, **esto no implica necesariamente que el planificador de procesos se ejecute automáticamente**. La ejecución del planificador depende de eventos específicos(como un bloqueo o una interrupción de reloj), no de la llamada al sistema en su.
    
    </aside>
    

### 11. Cual de las siguientes afirmaciones puede llevar a que un proceso A pase a estado de "Listo"

- [ ]  Cuando otro proceso B incrementa un semaforo binario, que el proceso A era el único que habia efectuado un down sobre el mismo semaforo cuando estaba en cero.
    
    <aside>
    ✅
    
    **Se libera un proceso bloqueado en el semáforo, cambiando a estado de listo.** Cuando el proceso B ejecuta la instrucción **`UP`**, sobre el mutex que el proceso A había ejecutado previamente una operación **`DOWN`** y se bloqueo. Con esto, finalmente se desbloquea y pasa a Listo.
    
    </aside>
    
- [ ]  Cuando el planificador detecta que ha expirado su tiempo de ejecución.
    
    <aside>
    ✅
    
    El planificador detecta que su quantum de tiempo ha expirado. Esto causa que A pase de “Ejecución” a “Listo”
    
    </aside>
    
- [ ]  Cuando un servicio de interrupción haya completado la lectura de un dispositivo(como el teclado), siendo que el proceso A se bloqueo en espera de esa lectura
    
    <aside>
    ✅
    
    Cuando s**e completa la operación de E/S por una rutina de interrupción**, y el proceso A estaba boqueado esperando ese evento, este se despierta y pasa a Listo
    
    </aside>
    
- [x]  Todas las anteriores son validas
- [ ]  Ninguna de las anteriores

### 12. Una forma de evitar el uso de tiempo ocioso de CPU, en un algoritmo de exclusión mutua es:

- [ ]  Utilizando una instrucción TSL, que cierre el bus de acceso a la memoria
    
    <aside>
    ❌
    
    La instrucción TSL **utiliza espera ocupada, garantizando la exclusión mutua**, pero que si permite el tiempo de espera excesivo de cola de procesos.
    
    </aside>
    
- [ ]  Desactivando interrupciones
    
    <aside>
    ❌
    
    Este método **deshabilita el planificador, haciendo que incluso empeore el tiempo ocioso de CPU**. 
    
    </aside>
    
- [ ]  Implementando una variable "Interés", que los proceso la activan para evitar la espera ocupada
    
    <aside>
    ❌
    
    Relacionando con el algoritmo de Peterson, que usa este tipo de variables**, si bien logra reducir la espera ocupada en ciertos escenarios, no la elimina completamente, ya que algunos bucles pueden seguir necesitando verificación activa**.
    
    </aside>
    
- [ ]  Las tres anteriores son validas
- [x]  Ninguna de las anteriores
    
    <aside>
    ✅
    
    La solución para **evitar completamente la espera ocupada** implica el uso de **semáforos con bloqueo. El proceso se bloquean y despierta mediante llamadas al sistema.**
    
    </aside>
    

### 13. La alternancia Estricta requiere que:

- [ ]  Un proceso no entre en su región critica hasta que el valor de **`turn`** se lo permita
    
    <aside>
    ✅
    
    Cada proceso verifica repetidamente la variable **`turn`** en unbucle y solo entra a su region critica cuando **`turn`** coincide con su identificador, garantizando que los procesos accedan en el orden definido por **`turn`**.
    
    </aside>
    

- [ ]  Dos procesos se alternen a través de una espera ocupada.
    
    <aside>
    ✅
    
    Si, el algoritmo utiliza una espera ocupada, donde los procesos consumen ciclos de CPU mientras esperan que **`turn`** cambie de valor
    
    </aside>
    
- [ ]  Dos procesos se alternen estrictamente luego de entrar a sus regiones criticas
    
    <aside>
    ✅
    
     Después de que un proceso sale de su región crítica, actualiza **`turn`** para asignar el turno al otro proceso (ej.: el proceso 0 establece **`turn = 1`**). Esto asegura una alternancia estricta y obligatoria entre los dos procesos
    
    </aside>
    

- [x]  Las tres anteriores son validas
- [ ]  Ninguna es valida.

### 14. La planificación por prioridad dinámica se calcula utilizando 1/n, donde n es:

- [ ]  La cantidad de veces que cada proceso uso el procesador.El nume
    
    <aside>
    ❌
    
    La planificación **se basa en tiempo de uso REAL, no en conteos de ejecuciones,** ya que el tiempo de CPU es mejor indicador del consumo de recursos.
    
    </aside>
    

- [ ]  La cantidad de procesos que están en memoria
    
    <aside>
    ❌
    
    El numero de procesos en memoria no se utiliza para calcular la prioridad Dinámica en los algoritmos.
    
    </aside>
    
- [x]  La cantidad de tiempo de procesador que el proceso utilizo la ultima vez
    
    <aside>
    ✅
    
    Se describe que **la prioridad de un proceso puede calcularse utilizando la formula 1/n**, donde n representa el tiempo de CPU que el proceso ha utilizado recientemente(Es decir, **la cantidad de tiempo de procesador que el proceso utilizo en su ultima ejecución o en un periodo reciente**). Mientras mas n procesos tengamos, menor 1/n tiempo de CPU tendrán.
    
    </aside>
    
- [ ]  Las tres anteriores pueden ser validas
- [ ]  Ninguna de las anteriores

### 15. Una ventaja de los mecanismos de Exclusión mutua sin espera ocupada es que:

- [ ]  El S.O. bloquea al planificador, para impedir que un proceso entre en la región critica
    
    <aside>
    ❌
    
    Bloquear al planificador **paralizaría todo el sistema, impidiendo la multitarea.** Tanenbaum no menciona esto como un mecanismo de exclusión mutua
    
    </aside>
    
- [ ]  El S.O. bloquea las interrupciones para impedir que un proceso entre en su región critica
    
    <aside>
    ❌
    
    Bloquear interrupciones **es una técnica de bajo nivel para regiones críticas muy corta**s, pero no es una ventaja de los mecanismos sin espera ocupada, al contrario, la termina causando.
    
    </aside>
    
- [x]  El S.O bloquea al proceso que intenta entrar en la región critica, por que entro otro antes
    
    <aside>
    ✅
    
    Cuando un proceso intenta entrar a una región crítica que está siendo utilizada por otro proceso, el sistema operativo lo **bloquea** (lo pone en estado de suspensión) y lo saca de la CPU, permitiendo que otros procesos útiles se ejecuten. Esto contrasta con la espera ocupada (busy waiting), donde el proceso consume activamente ciclos de CPU verificando repetidamente si puede entrar.
    
    </aside>
    
- [ ]  Las tres anteriores son correctas
- [ ]  Ninguna es correcta

### 16. El mecanismo de Exclusión Mutua con semáforos, debe implementarse con acciones atómicas, considerando el ejemplo del libro donde se aplican semáforos(Vacías, llenas, Mutex) para resolver el problema del productor-consumidor de un buffer compartido, cual de las siguientes afirmaciones es cierta.

- [ ]  La accion atómica se aplica cuando se ingresa un elemento en el buffer
    
    <aside>
    ❌
    
    La inserción de un elemento en el buffer ocurre dentro de la región critica protegida por el semáforo **`mutex`**, la atomicidad no se aplica directamente en esta accion.
    
    </aside>
    
- [x]  La accion atómica se aplica cuando se modifica cualquiera de los semáforos
    
    <aside>
    ✅
    
    Las operaciones atomicas **`DOWN`** y **`UP`** se aplican sobre los semaforos, y sirven para incrementar o decrementar su valor. En el ejemplo del problema productor-consumidor con semáforos (**`vacías`, `llenas`, `mutex`**), la atomicidad es crucial en las operaciones de estos semáforos, ya que garantizan la sincronización correcta entre procesos sin conflictos.
    
    </aside>
    
- [ ]  La accion atómica se aplica cuando se extrae un elemento del buffer
    
    <aside>
    ❌
    
    Incorrecta por la misma razón que la opción A. La extracción del buffer está protegida por `mutex`, pero la atomicidad crítica reside en las operaciones de los semáforos (`down` y `up`), no en la extracción misma.
    
    </aside>
    
- [ ]  Todas las anteriores son correctas
- [ ]  Ninguna de las anteriores

## Indicar V o F

### 8. Para muchas aplicaciones, un proceso necesita acceso exclusivo no solo a un recurso, si no a varios

<aside>
✅

**Verdadero:** En varias aplicaciones, como por ejemplo, el problema de Los Filosofos Comelones, o procesos que gestionan múltiples dispositivos, un proceso requiera acceder a mas de un recurso en ejecución para realizar su tarea.

</aside>

### 9. Un recurso apropiativo es uno que se puede quitar al proceso que lo posee sin efectos dañinos.

<aside>
✅

**Verdadero:**  Los recursos apropiativos pueden interferirse sin causar daños o perjudicar. En contraste, los algoritmos no apropiativos, son aquellos a los que quitarle el proceso puede resultar destructivo.

</aside>

### 10. Condición de exclusión mutua es cuando cada recurso se asigna en un momento dado solo a un proceso, o esta disponible.

<aside>
✅

Verdadero, es la definición de exclusión mutua, una de las 4 condiciones para que ocurra un interbloqueo.

</aside>

### 11. Un sistema Distribuido consiste en una colección de computadoras autónomas enlazadas por una red y equipadas con un sistema software distribuido que luce a los usuarios como si fuera en sistema único y centralizado.

<aside>
✅

Verdadero, la definición proporcionada consiste totalmente con la definición propuesto por Taneubaum

</aside>

### 12. Integridad de los datos significa que los usuarios sin autorización no deben ser capaces de modificar datos sin el permiso del propietario.

<aside>
✅

Verdadero, la definición agrega, ademas **protección contra modificación no solo por usuarios no autorizados, sino también por usuarios autorizados que intentan realizar cambios no permitidos**.

</aside>

### 13. Los sistemas computacionales están llenos de recursos que pueden ser utilizados por solo un proceso a la vez

<aside>
✅

Verdadero, esto describe correctamente a los recursos no compartibles, como por ejemplo, una impresora. Sin embargo, existen también los recursos compartibles.

</aside>